from telegram.ext import ContextTypes
import logging
from src.db import conn, cursor
from src.roles import role_descriptions, role_factions
from telegram.helpers import escape_markdown  # Newly added import

logger = logging.getLogger("Mafia Bot GameManagement.StartGame")


async def start_game(update: ContextTypes.DEFAULT_TYPE, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.debug("Starting the game.")
    user_id = update.effective_user.id

    # Retrieve game_id from context.user_data
    game_id = context.user_data.get('game_id')

    if not game_id:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Game not found.")
        return

    cursor.execute("SELECT moderator_id, started, randomness_method FROM Games WHERE game_id = ?", (game_id,))
    result = cursor.fetchone()
    if not result:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Game not found.")
        return
    moderator_id, started, randomness_method = result

    if user_id != moderator_id:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="You are not authorized to start this game.")
        return

    if started:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="The game has already started.")
        return

    cursor.execute("""
        SELECT Roles.user_id, Roles.role, Users.username
        FROM Roles
        JOIN Users ON Roles.user_id = Users.user_id
        WHERE Roles.game_id = ?
    """, (game_id,))
    player_roles = cursor.fetchall()
    logger.debug(f"Player roles: {player_roles}")

    if not player_roles or any(role is None or role == '' for _, role, _ in player_roles):
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Cannot start the game. Roles have not been assigned to all players."
        )
        return

    role_message = "Game started! Here are the assigned roles:\n"

    # Determine the randomness methodology based on the stored randomness_method
    if randomness_method == "Random.org":
        methodology_description = (
            "Randomness Methodology: Random.org API\n\n"
            "This game used the Random.org API to generate truly random numbers for role assignment. "
            "Random.org uses atmospheric noise to produce high-quality random numbers, which are "
            "considered more random than those generated by pseudo-random number algorithms typically "
            "used in computer programs. This method ensures a fair and unbiased distribution of roles. "
            "The same methodology is being used in national lotteries, sports events, and other scenarios, "
            "concerning billions of dollars at stake.\n\n"
            "If you think this is not fair, write your complaint on a paper, put it in a bottle, and throw it into the ocean. "
            "If I find it, I will consider it. I promise!"
        )
        randomness_method = "Random.org"
    else:
        methodology_description = (
            "Randomness Methodology: Python's random module\n\n"
            "There was a problem with the Random.org API, so this game used Python's built-in random module for role assignment. "
            "This module uses the Mersenne Twister algorithm, a pseudo-random number generator. While not truly random, "
            "it provides high-quality randomness suitable for most applications, including game role "
            "assignment. The seed for this generator is derived from the system time, ensuring "
            "different results each time the program runs. "
            "This method is more than enough for a game of Mafia."
        )
        randomness_method = "Python's random module"

    # Notify each player of their role and the randomness methodology
    for user_id, role, username in player_roles:
        if role:
            role_description = role_descriptions.get(role, "No description available.")
            role_faction = role_factions.get(role, "Unknown Faction")
            msg = (f"Hi {username}, your role is: {role} ({role_faction})\n\n"
                   f"Role Description:\n{role_description}\n\n{methodology_description}")
            try:
                safe_msg = escape_markdown(msg, version=2)  # Escape markdown characters
                await context.bot.send_message(
                    chat_id=user_id,
                    text=safe_msg,
                    parse_mode='MarkdownV2'
                )
                role_message += f"{username} (ID: {user_id}): {role}\n"
            except Exception as e:
                logger.error(f"Failed to send role to user {user_id}: {e}")
                try:
                    await context.bot.send_message(
                        chat_id=moderator_id,
                        text=f"Failed to send role to user {username} (ID: {user_id}). Please check their privacy settings."
                    )
                except Exception as ex:
                    logger.error(f"Failed to notify moderator about summary message for user {user_id}: {ex}")
        else:
            await context.bot.send_message(
                chat_id=user_id,
                text="Error: No role assigned. Please contact the game moderator."
            )

    # Send roles summary and randomness methodology to moderator
    safe_role_message = escape_markdown(role_message, version=2)
    await context.bot.send_message(
        chat_id=moderator_id,
        text=safe_role_message,
        parse_mode='MarkdownV2'
    )

    # Mark the game as started
    cursor.execute("UPDATE Games SET started = 1 WHERE game_id = ?", (game_id,))
    conn.commit()
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"The game has started! Roles, descriptions, and randomness methodology have been sent to all players. Method used: {randomness_method}"
    )
    logger.debug(f"Game {game_id} started using {randomness_method}")

async def start_latest_game(update: ContextTypes.DEFAULT_TYPE, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.debug("Starting the latest game created by the moderator.")
    user_id = update.effective_user.id

    # Retrieve the latest game created by the moderator that hasn't been started yet
    cursor.execute("""
        SELECT game_id, started, randomness_method
        FROM Games
        WHERE moderator_id = ?
        ORDER BY rowid DESC
        LIMIT 1
    """, (user_id,))
    result = cursor.fetchone()

    if not result:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="You have not created any games.")
        return

    game_id, started, randomness_method = result

    if started:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="The latest game you created has already started.")
        return

    # Store game_id in context.user_data
    context.user_data['game_id'] = game_id

    # ------------------- Commented Out Section -------------------
    # Previously, confirm_and_set_roles was called here, which sends the game summary.
    # Since roles should be confirmed manually, we remove this call.

    # success, method = await confirm_and_set_roles(update, context, game_id)
    # if not success:
    #     await context.bot.send_message(chat_id=update.effective_chat.id, text="Error setting roles. Please try again.")
    # else:
    #     await start_game(update, context)  # Call start_game without passcode
    #     await context.bot.send_message(
    #         chat_id=update.effective_chat.id,
    #         text=f"The game has started successfully!\nRandomness source: {method}."
    #     )
    # -------------------------------------------------------------

    # Instead, directly start the game assuming roles have already been set
    await start_game(update, context)
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="The game has started successfully!"
    )
    logger.debug(f"Game {game_id} started successfully.")